
## Memory Management and Dynamic Linking: Itanium vs. x86-64

The transition from Itanium (IA64) to x86-64 involves a complete change in the Application Binary Interface (ABI) and memory management subsystem.

### Shared Library Management: SHLI vs. glibc/ELF

HP-UX on Itanium uses the ELF object format, but the dynamic linking behavior retains legacy HP-UX characteristics.

* **HP-UX Dynamic Loader:** Uses dld.so. It historically respected the SHLIB\_PATH environment variable for 32-bit applications and LD\_LIBRARY\_PATH for 64-bit applications. The loader supports "depth-first" or "breadth-first" search orders depending on compilation flags (+std, \+compat).14  
* **SLES 16 Dynamic Loader:** Uses ld-linux-x86-64.so.2 (part of glibc). It **only** respects LD\_LIBRARY\_PATH. SHLIB\_PATH is ignored.

Critical Migration Action:  
Administrators migration scripts must be audited. Any script exporting SHLIB\_PATH must be rewritten to export LD\_LIBRARY\_PATH. Furthermore, relying on LD\_LIBRARY\_PATH for system-wide configuration is an anti-pattern in Linux. The correct method is to add the library directory to a file in /etc/ld.so.conf.d/ and run ldconfig to update the global cache /etc/ld.so.cache.

### Compilation and Symbol Versioning

When recompiling in-house C/C++ applications from HP-UX to SLES 16:

* **Compiler:** HP-UX uses the aCC (HP ANSI C++) compiler or cc. SLES 16 uses gcc (GNU Compiler Collection).  
* **Flags:** The HP-UX \+z or \+Z flags (for Position Independent Code \- PIC) must be replaced with \-fPIC in GCC. The \+b flag (to embed runpaths) translates to \-Wl,-rpath.18  
* **Glibc:** SLES 16 uses glibc (GNU C Library). Glibc utilizes strict **Symbol Versioning**. If an application is compiled against a specific version of a library, it expects that specific version of the symbol at runtime. This prevents the "DLL Hell" sometimes seen on older UNIX systems but requires that binaries be recompiled if the underlying library major version changes significantly. HP-UX's SHLI (Shared Library) versioning was often looser, allowing simpler symlink swaps to upgrade libraries.

### Memory Overcommit vs. Strict Allocation

HP-UX is conservative. A malloc() call generally reserves backing store immediately. If swap+RAM is full, malloc fails.  
SLES 16 (Linux kernel) is optimistic. It uses Overcommit. malloc almost always succeeds, returning a pointer to virtual memory. Physical memory is only allocated when the page is written to (Fault-in).  
Risk: If the system runs out of physical RAM, the Linux OOM Killer (Out of Memory Killer) activates. It uses a heuristic to select a process (often the one using the most memory, like a Database) and kill \-9 it to save the kernel.  
Mitigation for DB Servers:  
On SLES 16 hosting Oracle/SAP, administrators often tune /etc/sysctl.conf:

Bash

vm.overcommit\_memory \= 2  \# Strict accounting (like HP-UX)  
vm.overcommit\_ratio \= 50  \# Limit to Swap \+ 50% RAM

This forces the kernel to behave more like HP-UX, returning errors on malloc rather than killing random processes later.