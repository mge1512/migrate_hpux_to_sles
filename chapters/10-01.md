
## Init System and Service Management: From Sequence to Dependency

The most immediate and obvious change for an HP-UX administrator is the replacement of the sequential System V initialization system with systemd. To understand the magnitude of this shift, one must analyze the boot process of both systems.

### Theoretical Divergence: Deterministic Sequence vs. Goal-Oriented Parallelism

#### The HP-UX Boot Process

In HP-UX, the boot process is strictly linear. The Processor Dependent Code (PDC) loads the Initial System Loader (ISL), which loads hpux. The kernel spawns /sbin/init (PID 1). This process reads /etc/inittab, determines the default runlevel (usually 3 or 4), and begins executing scripts in /sbin/init.d/.  
These scripts are linked to directories like /sbin/rc3.d/ with names starting with S (Start) or K (Kill) followed by a number (e.g., S100nfs.client). The sequencer executes S100 before S200. This is imperative programming: "Do X, wait for it to finish, then do Y." If S100nfs.client hangs due to a DNS timeout, the entire boot process stalls. The administrator has complete visibility but limited flexibility; optimizing boot time requires manually renumbering scripts.

#### The SLES 16 Systemd Architecture

SLES 16 utilizes systemd, which views the boot process not as a sequence, but as a dependency graph. The administrator defines a "Target" (a desired state, e.g., multi-user.target). Systemd calculates the most efficient path to reach that state. If Unit A depends on Unit B, but Unit C is independent, systemd will start B and C simultaneously.

This approach, known as aggressive parallelization, drastically reduces boot times but introduces non-determinism in startup orderâ€”services start as soon as their dependencies are met, not at a fixed time. Furthermore, systemd utilizes Socket Activation, a concept foreign to HP-UX's standard init (though similar to inetd), where systemd listens on a network port on behalf of a service and only starts the daemon when the first packet arrives, further optimizing resource usage.

### Directory Structure and Runlevel Mapping

The rigid directory structure of HP-UX has been replaced by a split-location model in SLES 16 to support the distinction between vendor defaults and administrator overrides.

| Feature | HP-UX Implementation | SLES 16 Implementation | Context & Notes |
| :---- | :---- | :---- | :---- |
| **Boot Orchestrator** | /sbin/rc (The Sequencer) | /usr/lib/systemd/systemd | Systemd is the binary orchestrator; rc is a shell script. |
| **Script/Unit Location** | /sbin/init.d/ | /usr/lib/systemd/system/ (Vendor) /etc/systemd/system/ (Admin) | **Critical:** Never edit files in /usr/lib. Copy them to /etc/systemd/system/ to override.6 |
| **Runlevel 0 (Halt)** | /sbin/rc0.d | poweroff.target | Stops all services before halting. |
| **Runlevel s/S (Single-User)** | /sbin/rcS.d | rescue.target or emergency.target | Used for root password recovery and filesystem repair. |
| **Runlevel 3 (Multi)** | /sbin/rc3.d | multi-user.target | The standard server state for non-GUI systems. |
| **Runlevel 4/5 (GUI)** | /sbin/rc4.d | graphical.target | SLES 16 defaults to this if GNOME is installed. |
| **Runlevel 6 (Reboot)** | /sbin/rc6.d | reboot.target | Stops all services before rebooting. |
| **Config Configuration** | /etc/rc.config.d/\* | EnvironmentFile inside Unit | HP-UX sources variables from separate files; Systemd loads them as env vars. |

### The Command-Level Transition: systemctl

The systemctl command is the omnipotent tool in SLES 16, replacing init, rc, and direct script execution.

#### Scenario 1: Managing a Service (e.g., SSH)

| Function  |HP-UX                          |SLES 16                        |
|:----------|:------------------------------|:------------------------------|
| Start     |/sbin/init.d/secsh start       | systemctl start sshd.service |
| Stop      |/sbin/init.d/secsh stop        | systemctl stop sshd.service  |
| Status    |There is no native status command in the init script usually; admin checks `ps -ef `\| ` grep sshd.8 ` | systemctl status sshd.service |

*Insight:* The status command in systemd is far superior. It displays the service state (Active/Inactive), the main PID, the memory usage (via cgroups), and the last 10 lines of log output from Journald. This instant context is unavailable in HP-UX.9

#### Scenario 2: Enabling a Service at Boot


| Function    | HP-UX                       | SLES 16                     |
| :---------- | :-------------------------- | :-------------------------- |
| Enable      | The admin must edit /etc/rc.config.d/secsh and set SSHD\_START=1. This variable is checked by the script at runtime. | systemctl enable sshd.service |

*Linux Mechanism:* This command reads the \[Install\] section of the unit file and creates a symbolic link in /etc/systemd/system/multi-user.target.wants/ pointing to the unit. It is a filesystem operation, not a variable setting.

### Anatomy of a Systemd Unit vs. Init Script

To illustrate the shift from imperative scripting to declarative definition, we compare a theoretical custom service.

#### HP-UX /sbin/init.d/custom\_app (Abbreviated)

```bash
#!/sbin/sh  
# Source configuration  
if [ -f /etc/rc.config.d/custom_app ] ; then  
   . /etc/rc.config.d/custom_app  
fi

case $1 in  
'start_msg')  
    echo "Starting Custom App"  
    ;;  
'start')  
    if; then  
        # Manual PID management required  
        /opt/app/bin/server > /var/log/app.log 2>&1 &  
        echo $! > /var/run/custom_app.pid  
    fi  
    ;;  
'stop')  
    # Fragile kill logic  
    if [ -f /var/run/custom_app.pid ]; then  
        kill $(cat /var/run/custom_app.pid)  
    fi  
    ;;  
esac
```

*Critique:* The script must handle logging redirection, PID file creation, and variable sourcing manually. Error handling is the responsibility of the script author.

#### SLES 16 /etc/systemd/system/custom\_app.service

```TOML
[Unit]  
Description=Custom Application Service  
After=network-online.target remote-fs.target  
Wants=network-online.target

Type=simple  
ExecStart=/opt/app/bin/server  
# Systemd handles logging (stdout/stderr goes to Journal)  
StandardOutput=journal  
StandardError=journal  
# Automatic Restart Logic  
Restart=on-failure  
RestartSec=5s  
# Security Hardening (Unavailable in HP-UX Init)  
User=appuser  
Group=appgroup  
ProtectHome=true  
PrivateTmp=true

[Install]  
WantedBy=multi-user.target
```


*Analysis:* The unit file is declarative. The After= directive handles ordering. Restart=on-failure provides high availability functionality that would require a separate monitoring tool (like Monit or HP Serviceguard) on HP-UX. The security directives (ProtectHome, PrivateTmp) leverage kernel namespacing to sandbox the process, a feature HP-UX init scripts cannot easily replicate. 
